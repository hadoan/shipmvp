using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Linq;

[Generator]
public sealed class UowIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find classes with [UnitOfWork] attribute that implement IRequestHandler or IRepository
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax classDecl && 
                                    classDecl.AttributeLists.Count > 0,
                static (generatorContext, _) =>
                {
                    var classDecl = (ClassDeclarationSyntax)generatorContext.Node;
                    var model = generatorContext.SemanticModel;
                    var symbol = model.GetDeclaredSymbol(classDecl);
                    
                    if (symbol is null) return null;

                    // Check for UnitOfWork attribute
                    var hasUowAttribute = symbol.GetAttributes().Any(attr =>
                        attr.AttributeClass?.ToDisplayString() == "ShipMvp.Core.Persistence.UnitOfWorkAttribute");
                    
                    if (!hasUowAttribute) return null;

                    // Collect handler interfaces
                    var handlerIfaces = symbol.AllInterfaces
                        .Where(i => i.Name.StartsWith("IRequestHandler"))
                        .ToImmutableArray();

                    // Collect repository interfaces
                    var repoIfaces = symbol.AllInterfaces
                        .Where(ImplementsRepositoryInterface)
                        .ToImmutableArray();
                    
                    // Skip if neither handler nor repository interfaces found
                    if (handlerIfaces.Length == 0 && repoIfaces.Length == 0) return null;

                    return new HandlerInfo
                    {
                        Symbol = symbol,
                        Namespace = symbol.ContainingNamespace.ToDisplayString(),
                        ClassName = symbol.Name,
                        RequestHandlerInterfaces = handlerIfaces,
                        RepositoryInterfaces = repoIfaces
                    };
                })
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);

        // Generate wrapper classes
        context.RegisterSourceOutput(candidates.Collect(), 
            static (sourceContext, handlerInfos) =>
            {
                // Always generate a test file to verify the generator is running
                sourceContext.AddSource("GeneratorTest.g.cs", "// Generator is running");
                
                if (handlerInfos.IsEmpty) return;

                GenerateWrappers(sourceContext, handlerInfos);
                GenerateServiceRegistrations(sourceContext, handlerInfos);
            });
    }

    private static bool ImplementsRepositoryInterface(INamedTypeSymbol i)
    {
        // Check if this interface is exactly IRepository<T, TId>
        if (i.IsGenericType && i.OriginalDefinition.ToDisplayString() == "ShipMvp.Core.IRepository<T, TId>")
            return true;
            
        // Check base interfaces recursively
        return i.AllInterfaces.Any(baseInterface => 
            baseInterface.IsGenericType && 
            baseInterface.OriginalDefinition.ToDisplayString() == "ShipMvp.Core.IRepository<T, TId>");
    }

    private static void GenerateWrappers(SourceProductionContext context, ImmutableArray<HandlerInfo> handlerInfos)
    {
        foreach (var info in handlerInfos)
        {
            var source = GenerateWrapperClass(info);
            context.AddSource($"{info.ClassName}_UowWrapper.g.cs", source);
        }
    }

    private static void GenerateServiceRegistrations(SourceProductionContext context, ImmutableArray<HandlerInfo> handlerInfos)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("namespace ShipMvp.Core.Generated;");
        sb.AppendLine();
        sb.AppendLine("public static class UnitOfWorkServiceCollectionExtensions");
        sb.AppendLine("{");
        sb.AppendLine("    public static IServiceCollection AddGeneratedUnitOfWorkWrappers(this IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var info in handlerInfos)
        {
            // First register the original implementation
            sb.AppendLine($"        services.AddScoped<{info.Namespace}.{info.ClassName}>();");
            
            // Register handler interfaces
            foreach (var requestHandlerInterface in info.RequestHandlerInterfaces)
            {
                var interfaceDisplay = requestHandlerInterface.ToDisplayString();
                sb.AppendLine($"        services.AddScoped<{interfaceDisplay}, {info.Namespace}.Generated.{info.ClassName}_UowWrapper>();");
            }

            // Register repository interfaces
            foreach (var repositoryInterface in info.RepositoryInterfaces)
            {
                var interfaceDisplay = repositoryInterface.ToDisplayString();
                sb.AppendLine($"        services.AddScoped<{interfaceDisplay}, {info.Namespace}.Generated.{info.ClassName}_UowWrapper>();");
            }
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        context.AddSource("UnitOfWorkServiceRegistrations.g.cs", sb.ToString());
    }

    private static string GenerateWrapperClass(HandlerInfo info)
    {
        var sb = new StringBuilder();
        var wrapperClassName = $"{info.ClassName}_UowWrapper";
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"namespace {info.Namespace}.Generated;");
        sb.AppendLine();

        // Build interface list
        var allInterfaces = new List<string>();
        allInterfaces.AddRange(info.RequestHandlerInterfaces.Select(i => i.ToDisplayString()));
        allInterfaces.AddRange(info.RepositoryInterfaces.Select(i => i.ToDisplayString()));
        
        var interfaceList = string.Join(", ", allInterfaces);
        
        sb.AppendLine($"public sealed partial class {wrapperClassName} : {interfaceList}");
        sb.AppendLine("{");
        sb.AppendLine($"    private readonly {info.Namespace}.{info.ClassName} _inner;");
        sb.AppendLine("    private readonly global::ShipMvp.Core.Persistence.IUnitOfWork _uow;");
        sb.AppendLine();
        sb.AppendLine($"    public {wrapperClassName}(");
        sb.AppendLine($"        {info.Namespace}.{info.ClassName} inner,");
        sb.AppendLine("        global::ShipMvp.Core.Persistence.IUnitOfWork uow)");
        sb.AppendLine("    {");
        sb.AppendLine("        _inner = inner;");
        sb.AppendLine("        _uow = uow;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate handler methods
        foreach (var requestHandlerInterface in info.RequestHandlerInterfaces)
        {
            GenerateHandlerMethod(sb, requestHandlerInterface);
        }

        // Generate repository methods
        foreach (var repositoryInterface in info.RepositoryInterfaces)
        {
            GenerateRepositoryMethods(sb, repositoryInterface);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateHandlerMethod(StringBuilder sb, INamedTypeSymbol handlerInterface)
    {
        var methods = handlerInterface.GetMembers().OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.Ordinary && !m.IsStatic);

        foreach (var method in methods)
        {
            var returnType = method.ReturnType.ToDisplayString();
            var methodName = method.Name;
            var parameters = string.Join(", ", method.Parameters.Select(p => 
                $"{p.Type.ToDisplayString()} {p.Name}"));
            var paramNames = string.Join(", ", method.Parameters.Select(p => p.Name));

            // Check if method is async
            var isAsync = returnType.StartsWith("System.Threading.Tasks.Task");
            var asyncModifier = isAsync ? "async " : "";

            sb.AppendLine($"    public {asyncModifier}{returnType} {methodName}({parameters})");
            sb.AppendLine("    {");
            
            if (isAsync)
            {
                sb.AppendLine("        using var transaction = await _uow.BeginAsync();");
                if (returnType == "System.Threading.Tasks.Task")
                {
                    // Void async method
                    sb.AppendLine($"        await _inner.{methodName}({paramNames});");
                    sb.AppendLine("        await _uow.SaveChangesAsync();");
                    sb.AppendLine("        if (transaction is Microsoft.EntityFrameworkCore.Storage.IDbContextTransaction dbTx)");
                    sb.AppendLine("            await dbTx.CommitAsync();");
                }
                else
                {
                    // Value-returning async method
                    sb.AppendLine($"        var result = await _inner.{methodName}({paramNames});");
                    sb.AppendLine("        await _uow.SaveChangesAsync();");
                    sb.AppendLine("        if (transaction is Microsoft.EntityFrameworkCore.Storage.IDbContextTransaction dbTx)");
                    sb.AppendLine("            await dbTx.CommitAsync();");
                    sb.AppendLine("        return result;");
                }
            }
            else
            {
                // Sync method
                sb.AppendLine("        using var transaction = _uow.BeginAsync().GetAwaiter().GetResult();");
                sb.AppendLine($"        var result = _inner.{methodName}({paramNames});");
                sb.AppendLine("        _uow.SaveChangesAsync().GetAwaiter().GetResult();");
                sb.AppendLine("        if (transaction is Microsoft.EntityFrameworkCore.Storage.IDbContextTransaction dbTx)");
                sb.AppendLine("            dbTx.Commit();");
                sb.AppendLine("        return result;");
            }
            
            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

    private static void GenerateRepositoryMethods(StringBuilder sb, INamedTypeSymbol repositoryInterface)
    {
        var methods = repositoryInterface.GetMembers().OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.Ordinary && !m.IsStatic);

        foreach (var method in methods)
        {
            var returnType = method.ReturnType.ToDisplayString();
            var methodName = method.Name;
            var parameters = string.Join(", ", method.Parameters.Select(p => 
                $"{p.Type.ToDisplayString()} {p.Name}"));
            var paramNames = string.Join(", ", method.Parameters.Select(p => p.Name));

            // Check if method is async
            var isAsync = returnType.StartsWith("System.Threading.Tasks.Task");
            var isWriteOperation = IsWriteOperation(methodName);
            
            // Only add async modifier for write operations that need UoW wrapping
            var asyncModifier = (isAsync && isWriteOperation) ? "async " : "";

            sb.AppendLine($"    public {asyncModifier}{returnType} {methodName}({parameters})");
            sb.AppendLine("    {");
            
            // Only wrap write operations in transactions
            if (isWriteOperation)
            {
                if (isAsync)
                {
                    sb.AppendLine("        using var transaction = await _uow.BeginAsync();");
                    if (returnType == "System.Threading.Tasks.Task")
                    {
                        // Void async method
                        sb.AppendLine($"        await _inner.{methodName}({paramNames});");
                        sb.AppendLine("        await _uow.SaveChangesAsync();");
                        sb.AppendLine("        if (transaction is Microsoft.EntityFrameworkCore.Storage.IDbContextTransaction dbTx)");
                        sb.AppendLine("            await dbTx.CommitAsync();");
                    }
                    else
                    {
                        // Value-returning async method
                        sb.AppendLine($"        var result = await _inner.{methodName}({paramNames});");
                        sb.AppendLine("        await _uow.SaveChangesAsync();");
                        sb.AppendLine("        if (transaction is Microsoft.EntityFrameworkCore.Storage.IDbContextTransaction dbTx)");
                        sb.AppendLine("            await dbTx.CommitAsync();");
                        sb.AppendLine("        return result;");
                    }
                }
                else
                {
                    // Sync method (less likely for repositories)
                    sb.AppendLine("        using var transaction = _uow.BeginAsync().GetAwaiter().GetResult();");
                    sb.AppendLine($"        var result = _inner.{methodName}({paramNames});");
                    sb.AppendLine("        _uow.SaveChangesAsync().GetAwaiter().GetResult();");
                    sb.AppendLine("        if (transaction is Microsoft.EntityFrameworkCore.Storage.IDbContextTransaction dbTx)");
                    sb.AppendLine("            dbTx.Commit();");
                    sb.AppendLine("        return result;");
                }
            }
            else
            {
                // Read operations - direct passthrough
                if (isAsync)
                {
                    sb.AppendLine($"        return _inner.{methodName}({paramNames});");
                }
                else
                {
                    sb.AppendLine($"        return _inner.{methodName}({paramNames});");
                }
            }
            
            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

    private static bool IsWriteOperation(string methodName)
    {
        var writeOperations = new[] { "Add", "Insert", "Create", "Update", "Delete", "Remove", "Save" };
        return writeOperations.Any(op => methodName.StartsWith(op, StringComparison.OrdinalIgnoreCase));
    }

    private class HandlerInfo
    {
        public INamedTypeSymbol Symbol { get; set; }
        public string Namespace { get; set; }
        public string ClassName { get; set; }
        public ImmutableArray<INamedTypeSymbol> RequestHandlerInterfaces { get; set; }
        public ImmutableArray<INamedTypeSymbol> RepositoryInterfaces { get; set; }
    }
}
